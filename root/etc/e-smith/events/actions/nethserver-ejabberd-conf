#!/usr/bin/perl
#
# Copyright (C) 2012 Nethesis S.r.l.
# http://www.nethesis.it - support@nethesis.it
# 
# This script is part of NethServer.
# 
# NethServer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License,
# or any later version.
# 
# NethServer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with NethServer.  If not, see <http://www.gnu.org/licenses/>.
#

use strict;
use NethServer::Service;
use NethServer::Directory;
use esmith::AccountsDB;
use User::pwent;


my $ldap = NethServer::Directory::connect();
my $internalSuffix = NethServer::Directory::getInternalSuffix();
my $exitCode = 0;


#
# Adjust LDAP ACLs to allow dovecot read on any field through ldapi:// socket.
#
my $ldapAccessDirective = 'by dn.exact="cn=ejabberd,'.$internalSuffix.'" read';

NethServer::Directory::addAccessDirective($ldapAccessDirective, '*');


# Create ejabberd ldap user

{ # BEGIN LDAP

    my $password = NethServer::Directory::getUserPassword('ejabberd', 0);

    my @entries = (
        [ 'cn=ejabberd,' . $internalSuffix,
          attrs => [
              objectClass => ['device', 'simpleSecurityObject'],
              cn => 'ejabberd',
              userPassword => NethServer::Directory::getUserPassword('ejabberd', 1),
              description => 'Ejabberd management account'
          ] 
        ]
        );

    foreach(@entries) {
        my $message = $ldap->merge(@{$_});
        if($message->is_error()) {
            warn 'error merging ' . $_[0];
            $exitCode ++;
        }
    }

} # END LDAP



# Add ejabberd service 

NethServer::Service::manage_add('nethserver-ejabberd', 'ejabberd');


# Add ejabber admin group: jabberadmins

my $luseradd = '/usr/sbin/luseradd';
my $accountsDb = esmith::AccountsDB->open() or die("Could not open AccountsDB");

my $entries = {
    jabberadmins => {
        type => 'group',
        name => 'Jabber Admins'
    },
};

sub initializeGroupRecord
{
    my $groupName = shift;
    my $description = shift;

    # note that $group is a user account passwd entry:
    my $pwent = getpwnam($groupName);

    if( ! $pwent) {
        warn "Could not find system group $groupName";
        return 0;  # failure;
    }

    my $groupRecord = $accountsDb->get($groupName);

    # Nothing to to if the record does not exists, or is already initialized.
    if( ! $groupRecord || $groupRecord->prop('Uid') || $groupRecord->prop('Gid')) {
        return 1; # success -- nothing to do.
    }

    # This is a strict check:
    if( $groupRecord->prop('type') ne 'group') {
        warn "The `$groupName` account is not of type group";
        return 0; # error
    }

    # Initialize the group record:
    $groupRecord->merge_props(
        'Gid' => $pwent->gid,
        'Uid' => $pwent->uid,
        'Description' => $description,
        'Removable' => 'no'
        );

    return 1; # success
}

while ( my ($group, $entry) = each(%$entries) ) {

    if(getgrnam($group)) {
        # warn "Ignoring existing group `$group`..\n";
        next;
    }

    # Create a system user and private group entry:
    qx($luseradd -s /bin/false -r $group);
    if($? != 0) {
        warn "Failed to create system samba group `$group`";
        $exitCode ++;
        next;
    }

    if( ! initializeGroupRecord($group, $entry->{'name'})) {
        $exitCode ++;
    }

}


exit($exitCode);

